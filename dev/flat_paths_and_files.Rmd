---
title: "flat_paths_and_files.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# current_script_location
    
```{r development-current_script_location}
# You can prepare the code of the current_script_location() function here
```
  
```{r function-current_script_location}
#'RStudio only - Get exact path of the currently opened script
#' 
#' For this function to work, one must use RStudio and have an opened source document. 
#' There is exceptionnaly no example and exact test since these are running in background sessions in checks. 
#' 
#' @return A character vector indicating exact path of currently opened script
#' @export
#'
current_script_location <- function () {

  if (.Platform$GUI != "RStudio") {
    
    stop("This function is not working without RStudio")
  }
  
  dirname(
    path = rstudioapi::getSourceEditorContext()$path)
}
```
    
```{r tests-current_script_location}
test_that("No exact test but RStudio should not be available in the tests", {
  
  expect_false(.Platform$GUI == "RStudio")
  
  expect_error(current_script_location())
})
```
  
```{r dev, eval = FALSE}
# Trial to do a more precise test of current_script_location() : 
 temp_filepath <- tempfile(pattern = "csloc")
  code <- "
  out_path <- current_script_location()
  writeLines(out_path, file.path(out_path, 'out_code'))
  "
  writeLines(text = code, con = temp_filepath)
  job::job({source(temp_filepath)})
  out_code_text <- readLines(file.path(basename(temp_filepath), "out_code"))
    
  expect_identical(
    object = current_script_location(), 
    expected = out_code_text)
```

# folder_structure_replicate
    
```{r development-folder_structure_replicate}
# You can prepare the code of the folder_structure_replicate() function here
```
  
```{r function-folder_structure_replicate}
#' Replicate the folder structure of a given directory
#'
#' @param dir Path of directory which structure will be replicated
#' @param to Path of an output directory in which replicated structured will be placed
#' @importFrom magrittr %>%
#' @export
#'
folder_structure_replicate <- function (dir, to) {

  requireNamespace("magrittr")

  if (isTRUE(identical(dir, to))) {
    
    stop(glue::glue("The arguments dir and to must not be identical"))
  }
  
  if (isTRUE(
    length(list.dirs(to, recursive = FALSE)) > 0)) {
    
    stop(glue::glue("For security reasons, {to} must be an empty directory"))
  }
  
  # Warnings are suppressed because of the two security checks above: 
  suppressWarnings({
    
    list.dirs(dir, full.names = FALSE) %>%
      (\(l) for (i in l)
        dir.create(file.path(to, i), recursive = TRUE))
  })
  
}
```
  
```{r example-folder_structure_replicate}
library(magrittr)

temp_dir_to_replicate <- tempfile()
dir.create(temp_dir_to_replicate)

dir.create(file.path(temp_dir_to_replicate, "dir1"))
dir.create(file.path(temp_dir_to_replicate, "dir2"))

temp_dir_out <- tempfile()
dir.create(temp_dir_out)

folder_structure_replicate(
  dir = temp_dir_to_replicate, 
  to = temp_dir_out)

unlink(temp_dir_to_replicate)
unlink(temp_dir_out)
```
  
```{r tests-folder_structure_replicate}
test_that("Structures are effectively the same", {
  
  library(magrittr)
  
  temp_dir_to_replicate <- tempfile()
  dir.create(temp_dir_to_replicate)
  
  dir.create(file.path(temp_dir_to_replicate, "dir1"))
  dir.create(file.path(temp_dir_to_replicate, "dir2"))
  
  temp_dir_out <- tempfile()
  dir.create(temp_dir_out)
  
  folder_structure_replicate(
  dir = temp_dir_to_replicate, 
  to = temp_dir_out)
  
  ldir_in <- temp_dir_to_replicate %>% 
    (\(t) list.dirs(t) %>% 
       (\(l) l[l != t]))
  ldir_out <- temp_dir_to_replicate %>% 
    (\(t) list.dirs(t) %>% 
       (\(l) l[l != t]))
  
  expect_identical(
    object = ldir_in, 
    expected = ldir_out
  )
})
```
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_paths_and_files.Rmd", 
               vignette_name = NA)
```

